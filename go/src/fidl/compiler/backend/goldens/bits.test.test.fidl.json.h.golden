// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/header.h"


namespace test {
namespace name {

enum class MyBits : uint32_t {
  MY_FIRST_BIT = 1u,
  MY_OTHER_BIT = 2u,
};

const static MyBits MyBitsMask = static_cast<MyBits>(3u);

inline zx_status_t Clone(::test::name::MyBits value,
                         ::test::name::MyBits* result) {
  *result = value;
  return ZX_OK;
}

constexpr inline ::test::name::MyBits operator|(::test::name::MyBits _lhs,
                                                         ::test::name::MyBits _rhs) {
  return static_cast<::test::name::MyBits>(
    static_cast<uint32_t>(_lhs) | static_cast<uint32_t>(_rhs));
}

constexpr inline ::test::name::MyBits& operator|=(::test::name::MyBits& _lhs,
                                                           ::test::name::MyBits _rhs) {
  _lhs = _lhs | _rhs;
  return _lhs;
}

constexpr inline ::test::name::MyBits operator&(::test::name::MyBits _lhs,
                                                         ::test::name::MyBits _rhs) {
  return static_cast<::test::name::MyBits>(
    static_cast<uint32_t>(_lhs) & static_cast<uint32_t>(_rhs));
}

constexpr inline ::test::name::MyBits& operator&=(::test::name::MyBits& _lhs,
                                                           ::test::name::MyBits _rhs) {
  _lhs = _lhs & _rhs;
  return _lhs;
}

constexpr inline ::test::name::MyBits operator^(::test::name::MyBits _lhs,
                                                         ::test::name::MyBits _rhs) {
  return static_cast<::test::name::MyBits>(
    static_cast<uint32_t>(_lhs) ^ static_cast<uint32_t>(_rhs));
}

constexpr inline ::test::name::MyBits& operator^=(::test::name::MyBits& _lhs,
                                                           ::test::name::MyBits _rhs) {
  _lhs = _lhs ^ _rhs;
  return _lhs;
}

constexpr inline ::test::name::MyBits operator~(::test::name::MyBits _value) {
  return static_cast<::test::name::MyBits>(
    ~static_cast<uint32_t>(_value) & static_cast<uint32_t>(MyBitsMask));
}

}  // namespace name
}  // namespace test
namespace fidl {

template <>
struct CodingTraits<::test::name::MyBits> {
  static constexpr size_t encoded_size = sizeof(::test::name::MyBits);
  static void Encode(Encoder* encoder, ::test::name::MyBits* value, size_t offset) {
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::name::MyBits* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::name::MyBits>(underlying);
  }
};

inline zx_status_t Clone(::test::name::MyBits value,
                         ::test::name::MyBits* result) {
  return ::test::name::Clone(value, result);
}

template<>
struct Equality<::test::name::MyBits> {
  static inline bool Equals(const ::test::name::MyBits& _lhs, const ::test::name::MyBits& _rhs) {
    uint32_t _lhs_underlying = static_cast<uint32_t>(_lhs);
    uint32_t _rhs_underlying = static_cast<uint32_t>(_rhs);
    return Equality<uint32_t>::Equals(_lhs_underlying, _rhs_underlying);
  }
};}  // namespace fidl
