// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.enums.lower;
enum abstract { MEMBER = 1; };
enum alignas { MEMBER = 1; };
enum alignof { MEMBER = 1; };
enum and { MEMBER = 1; };
enum and_eq { MEMBER = 1; };
enum as { MEMBER = 1; };
enum asm { MEMBER = 1; };
enum assert { MEMBER = 1; };
enum async { MEMBER = 1; };
enum atomic_cancel { MEMBER = 1; };
enum atomic_commit { MEMBER = 1; };
enum atomic_noexcept { MEMBER = 1; };
enum auto { MEMBER = 1; };
enum await { MEMBER = 1; };
enum become { MEMBER = 1; };
enum bitand { MEMBER = 1; };
enum bitor { MEMBER = 1; };
enum bool { MEMBER = 1; };
enum box { MEMBER = 1; };
enum break { MEMBER = 1; };
enum byte { MEMBER = 1; };
enum case { MEMBER = 1; };
enum catch { MEMBER = 1; };
enum chan { MEMBER = 1; };
enum char { MEMBER = 1; };
enum char16_t { MEMBER = 1; };
enum char32_t { MEMBER = 1; };
enum class { MEMBER = 1; };
enum co_await { MEMBER = 1; };
enum co_return { MEMBER = 1; };
enum co_yield { MEMBER = 1; };
enum coding_traits { MEMBER = 1; };
enum compl { MEMBER = 1; };
enum concept { MEMBER = 1; };
enum const { MEMBER = 1; };
enum const_cast { MEMBER = 1; };
enum constexpr { MEMBER = 1; };
enum continue { MEMBER = 1; };
enum controller { MEMBER = 1; };
enum covariant { MEMBER = 1; };
enum crate { MEMBER = 1; };
enum decltype { MEMBER = 1; };
enum decoder { MEMBER = 1; };
enum default { MEMBER = 1; };
enum defer { MEMBER = 1; };
enum deferred { MEMBER = 1; };
enum delete { MEMBER = 1; };
enum do { MEMBER = 1; };
enum double { MEMBER = 1; };
enum dynamic { MEMBER = 1; };
enum dynamic_cast { MEMBER = 1; };
enum else { MEMBER = 1; };
enum encoder { MEMBER = 1; };
enum ensure_values_instantiated { MEMBER = 1; };
enum enum { MEMBER = 1; };
enum err { MEMBER = 1; };
enum explicit { MEMBER = 1; };
enum export { MEMBER = 1; };
enum extends { MEMBER = 1; };
enum extern { MEMBER = 1; };
enum external { MEMBER = 1; };
enum factory { MEMBER = 1; };
enum fallthrough { MEMBER = 1; };
enum false { MEMBER = 1; };
enum fidl { MEMBER = 1; };
enum fidl_type { MEMBER = 1; };
enum final { MEMBER = 1; };
enum finally { MEMBER = 1; };
enum float { MEMBER = 1; };
enum fn { MEMBER = 1; };
enum for { MEMBER = 1; };
enum friend { MEMBER = 1; };
enum func { MEMBER = 1; };
enum future { MEMBER = 1; };
enum futures { MEMBER = 1; };
enum get { MEMBER = 1; };
enum go { MEMBER = 1; };
enum goto { MEMBER = 1; };
enum has_invalid_tag { MEMBER = 1; };
enum hash_code { MEMBER = 1; };
enum if { MEMBER = 1; };
enum impl { MEMBER = 1; };
enum implements { MEMBER = 1; };
enum import { MEMBER = 1; };
enum in { MEMBER = 1; };
enum index { MEMBER = 1; };
enum inline { MEMBER = 1; };
enum int { MEMBER = 1; };
enum int16 { MEMBER = 1; };
enum int32 { MEMBER = 1; };
enum int64 { MEMBER = 1; };
enum int8 { MEMBER = 1; };
enum interface { MEMBER = 1; };
enum is { MEMBER = 1; };
enum let { MEMBER = 1; };
enum lhs { MEMBER = 1; };
enum library { MEMBER = 1; };
enum list { MEMBER = 1; };
enum long { MEMBER = 1; };
enum loop { MEMBER = 1; };
enum macro { MEMBER = 1; };
enum map { MEMBER = 1; };
enum match { MEMBER = 1; };
enum mixin { MEMBER = 1; };
enum mod { MEMBER = 1; };
enum module { MEMBER = 1; };
enum move { MEMBER = 1; };
enum mut { MEMBER = 1; };
enum mutable { MEMBER = 1; };
enum namespace { MEMBER = 1; };
enum never { MEMBER = 1; };
enum new { MEMBER = 1; };
enum no_such_method { MEMBER = 1; };
enum noexcept { MEMBER = 1; };
enum none { MEMBER = 1; };
enum not { MEMBER = 1; };
enum not_eq { MEMBER = 1; };
enum null { MEMBER = 1; };
enum nullptr { MEMBER = 1; };
enum num { MEMBER = 1; };
enum object { MEMBER = 1; };
enum offset { MEMBER = 1; };
enum offsetof { MEMBER = 1; };
enum ok { MEMBER = 1; };
enum on_open { MEMBER = 1; };
enum operator { MEMBER = 1; };
enum option { MEMBER = 1; };
enum or { MEMBER = 1; };
enum or_eq { MEMBER = 1; };
enum override { MEMBER = 1; };
enum package { MEMBER = 1; };
enum part { MEMBER = 1; };
enum priv { MEMBER = 1; };
enum private { MEMBER = 1; };
enum proc { MEMBER = 1; };
enum protected { MEMBER = 1; };
enum proxy { MEMBER = 1; };
enum pub { MEMBER = 1; };
enum public { MEMBER = 1; };
enum pure { MEMBER = 1; };
enum range { MEMBER = 1; };
enum ref { MEMBER = 1; };
enum register { MEMBER = 1; };
enum reinterpret_cast { MEMBER = 1; };
enum requires { MEMBER = 1; };
enum result { MEMBER = 1; };
enum rethrow { MEMBER = 1; };
enum return { MEMBER = 1; };
enum rhs { MEMBER = 1; };
enum rune { MEMBER = 1; };
enum runtime_type { MEMBER = 1; };
enum select { MEMBER = 1; };
enum self { MEMBER = 1; };
enum send { MEMBER = 1; };
enum set { MEMBER = 1; };
enum set_controller { MEMBER = 1; };
enum short { MEMBER = 1; };
enum signed { MEMBER = 1; };
enum sizeof { MEMBER = 1; };
enum some { MEMBER = 1; };
enum static { MEMBER = 1; };
enum static_assert { MEMBER = 1; };
enum static_cast { MEMBER = 1; };
enum stream { MEMBER = 1; };
enum string { MEMBER = 1; };
enum struct { MEMBER = 1; };
enum stub { MEMBER = 1; };
enum super { MEMBER = 1; };
enum switch { MEMBER = 1; };
enum synchronized { MEMBER = 1; };
enum template { MEMBER = 1; };
enum this { MEMBER = 1; };
enum thread_local { MEMBER = 1; };
enum throw { MEMBER = 1; };
enum to_string { MEMBER = 1; };
enum trait { MEMBER = 1; };
enum true { MEMBER = 1; };
enum try { MEMBER = 1; };
enum type { MEMBER = 1; };
enum typedef { MEMBER = 1; };
enum typeid { MEMBER = 1; };
enum typename { MEMBER = 1; };
enum typeof { MEMBER = 1; };
enum uint16 { MEMBER = 1; };
enum uint32 { MEMBER = 1; };
enum uint64 { MEMBER = 1; };
enum uint8 { MEMBER = 1; };
enum union { MEMBER = 1; };
enum unsafe { MEMBER = 1; };
enum unsigned { MEMBER = 1; };
enum unsized { MEMBER = 1; };
enum use { MEMBER = 1; };
enum using { MEMBER = 1; };
enum value { MEMBER = 1; };
enum value_of { MEMBER = 1; };
enum value_union { MEMBER = 1; };
enum values_map { MEMBER = 1; };
enum var { MEMBER = 1; };
enum vec { MEMBER = 1; };
enum virtual { MEMBER = 1; };
enum void { MEMBER = 1; };
enum volatile { MEMBER = 1; };
enum wchar_t { MEMBER = 1; };
enum where { MEMBER = 1; };
enum which { MEMBER = 1; };
enum while { MEMBER = 1; };
enum with { MEMBER = 1; };
enum xor { MEMBER = 1; };
enum xor_eq { MEMBER = 1; };
enum xunion { MEMBER = 1; };
enum yield { MEMBER = 1; };
enum zx { MEMBER = 1; };
enum DangerousMembers {
  abstract = 0;
  alignas = 1;
  alignof = 2;
  and = 3;
  and_eq = 4;
  as = 5;
  asm = 6;
  assert = 7;
  async = 8;
  atomic_cancel = 9;
  atomic_commit = 10;
  atomic_noexcept = 11;
  auto = 12;
  await = 13;
  become = 14;
  bitand = 15;
  bitor = 16;
  bool = 17;
  box = 18;
  break = 19;
  byte = 20;
  case = 21;
  catch = 22;
  chan = 23;
  char = 24;
  char16_t = 25;
  char32_t = 26;
  class = 27;
  co_await = 28;
  co_return = 29;
  co_yield = 30;
  coding_traits = 31;
  compl = 32;
  concept = 33;
  const = 34;
  const_cast = 35;
  constexpr = 36;
  continue = 37;
  controller = 38;
  covariant = 39;
  crate = 40;
  decltype = 41;
  decoder = 42;
  default = 43;
  defer = 44;
  deferred = 45;
  delete = 46;
  do = 47;
  double = 48;
  dynamic = 49;
  dynamic_cast = 50;
  else = 51;
  encoder = 52;
  ensure_values_instantiated = 53;
  enum = 54;
  err = 55;
  explicit = 56;
  export = 57;
  extends = 58;
  extern = 59;
  external = 60;
  factory = 61;
  fallthrough = 62;
  false = 63;
  fidl = 64;
  fidl_type = 65;
  final = 66;
  finally = 67;
  float = 68;
  fn = 69;
  for = 70;
  friend = 71;
  func = 72;
  future = 73;
  futures = 74;
  get = 75;
  go = 76;
  goto = 77;
  has_invalid_tag = 78;
  hash_code = 79;
  if = 80;
  impl = 81;
  implements = 82;
  import = 83;
  in = 84;
  index = 85;
  inline = 86;
  int = 87;
  int16 = 88;
  int32 = 89;
  int64 = 90;
  int8 = 91;
  interface = 92;
  is = 93;
  let = 94;
  lhs = 95;
  library = 96;
  list = 97;
  long = 98;
  loop = 99;
  macro = 100;
  map = 101;
  match = 102;
  mixin = 103;
  mod = 104;
  module = 105;
  move = 106;
  mut = 107;
  mutable = 108;
  namespace = 109;
  never = 110;
  new = 111;
  no_such_method = 112;
  noexcept = 113;
  none = 114;
  not = 115;
  not_eq = 116;
  null = 117;
  nullptr = 118;
  num = 119;
  object = 120;
  offset = 121;
  offsetof = 122;
  ok = 123;
  on_open = 124;
  operator = 125;
  option = 126;
  or = 127;
  or_eq = 128;
  override = 129;
  package = 130;
  part = 131;
  priv = 132;
  private = 133;
  proc = 134;
  protected = 135;
  proxy = 136;
  pub = 137;
  public = 138;
  pure = 139;
  range = 140;
  ref = 141;
  register = 142;
  reinterpret_cast = 143;
  requires = 144;
  result = 145;
  rethrow = 146;
  return = 147;
  rhs = 148;
  rune = 149;
  runtime_type = 150;
  select = 151;
  self = 152;
  send = 153;
  set = 154;
  set_controller = 155;
  short = 156;
  signed = 157;
  sizeof = 158;
  some = 159;
  static = 160;
  static_assert = 161;
  static_cast = 162;
  stream = 163;
  string = 164;
  struct = 165;
  stub = 166;
  super = 167;
  switch = 168;
  synchronized = 169;
  template = 170;
  this = 171;
  thread_local = 172;
  throw = 173;
  to_string = 174;
  trait = 175;
  true = 176;
  try = 177;
  type = 178;
  typedef = 179;
  typeid = 180;
  typename = 181;
  typeof = 182;
  uint16 = 183;
  uint32 = 184;
  uint64 = 185;
  uint8 = 186;
  union = 187;
  unsafe = 188;
  unsigned = 189;
  unsized = 190;
  use = 191;
  using = 192;
  value = 193;
  value_of = 194;
  value_union = 195;
  values_map = 196;
  var = 197;
  vec = 198;
  virtual = 199;
  void = 200;
  volatile = 201;
  wchar_t = 202;
  where = 203;
  which = 204;
  while = 205;
  with = 206;
  xor = 207;
  xor_eq = 208;
  xunion = 209;
  yield = 210;
  zx = 211;
};
