// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.struct.types.upper;
using membertype = uint32;
struct ABSTRACT { membertype member = 1; };
struct ALIGNAS { membertype member = 1; };
struct ALIGNOF { membertype member = 1; };
struct AND { membertype member = 1; };
struct AND_EQ { membertype member = 1; };
struct AS { membertype member = 1; };
struct ASM { membertype member = 1; };
struct ASSERT { membertype member = 1; };
struct ASYNC { membertype member = 1; };
struct ATOMIC_CANCEL { membertype member = 1; };
struct ATOMIC_COMMIT { membertype member = 1; };
struct ATOMIC_NOEXCEPT { membertype member = 1; };
struct AUTO { membertype member = 1; };
struct AWAIT { membertype member = 1; };
struct BECOME { membertype member = 1; };
struct BITAND { membertype member = 1; };
struct BITOR { membertype member = 1; };
struct BOOL { membertype member = 1; };
struct BOX { membertype member = 1; };
struct BREAK { membertype member = 1; };
struct BYTE { membertype member = 1; };
struct CASE { membertype member = 1; };
struct CATCH { membertype member = 1; };
struct CHAN { membertype member = 1; };
struct CHAR { membertype member = 1; };
struct CHAR16_T { membertype member = 1; };
struct CHAR32_T { membertype member = 1; };
struct CLASS { membertype member = 1; };
struct CO_AWAIT { membertype member = 1; };
struct CO_RETURN { membertype member = 1; };
struct CO_YIELD { membertype member = 1; };
struct CODING_TRAITS { membertype member = 1; };
struct COMPL { membertype member = 1; };
struct CONCEPT { membertype member = 1; };
struct CONST { membertype member = 1; };
struct CONST_CAST { membertype member = 1; };
struct CONSTEXPR { membertype member = 1; };
struct CONTINUE { membertype member = 1; };
struct CONTROLLER { membertype member = 1; };
struct COVARIANT { membertype member = 1; };
struct CRATE { membertype member = 1; };
struct DECLTYPE { membertype member = 1; };
struct DECODER { membertype member = 1; };
struct DEFAULT { membertype member = 1; };
struct DEFER { membertype member = 1; };
struct DEFERRED { membertype member = 1; };
struct DELETE { membertype member = 1; };
struct DO { membertype member = 1; };
struct DOUBLE { membertype member = 1; };
struct DYNAMIC { membertype member = 1; };
struct DYNAMIC_CAST { membertype member = 1; };
struct ELSE { membertype member = 1; };
struct ENCODER { membertype member = 1; };
struct ENSURE_VALUES_INSTANTIATED { membertype member = 1; };
struct ENUM { membertype member = 1; };
struct ERR { membertype member = 1; };
struct EXPLICIT { membertype member = 1; };
struct EXPORT { membertype member = 1; };
struct EXTENDS { membertype member = 1; };
struct EXTERN { membertype member = 1; };
struct EXTERNAL { membertype member = 1; };
struct FACTORY { membertype member = 1; };
struct FALLTHROUGH { membertype member = 1; };
struct FALSE { membertype member = 1; };
struct FIDL { membertype member = 1; };
struct FIDL_TYPE { membertype member = 1; };
struct FINAL { membertype member = 1; };
struct FINALLY { membertype member = 1; };
struct FLOAT { membertype member = 1; };
struct FN { membertype member = 1; };
struct FOR { membertype member = 1; };
struct FRIEND { membertype member = 1; };
struct FUNC { membertype member = 1; };
struct FUTURE { membertype member = 1; };
struct FUTURES { membertype member = 1; };
struct GET { membertype member = 1; };
struct GO { membertype member = 1; };
struct GOTO { membertype member = 1; };
struct HAS_INVALID_TAG { membertype member = 1; };
struct HASH_CODE { membertype member = 1; };
struct IF { membertype member = 1; };
struct IMPL { membertype member = 1; };
struct IMPLEMENTS { membertype member = 1; };
struct IMPORT { membertype member = 1; };
struct IN { membertype member = 1; };
struct INDEX { membertype member = 1; };
struct INLINE { membertype member = 1; };
struct INT { membertype member = 1; };
struct INT16 { membertype member = 1; };
struct INT32 { membertype member = 1; };
struct INT64 { membertype member = 1; };
struct INT8 { membertype member = 1; };
struct INTERFACE { membertype member = 1; };
struct IS { membertype member = 1; };
struct LET { membertype member = 1; };
struct LHS { membertype member = 1; };
struct LIBRARY { membertype member = 1; };
struct LIST { membertype member = 1; };
struct LONG { membertype member = 1; };
struct LOOP { membertype member = 1; };
struct MACRO { membertype member = 1; };
struct MAP { membertype member = 1; };
struct MATCH { membertype member = 1; };
struct MIXIN { membertype member = 1; };
struct MOD { membertype member = 1; };
struct MODULE { membertype member = 1; };
struct MOVE { membertype member = 1; };
struct MUT { membertype member = 1; };
struct MUTABLE { membertype member = 1; };
struct NAMESPACE { membertype member = 1; };
struct NEVER { membertype member = 1; };
struct NEW { membertype member = 1; };
struct NO_SUCH_METHOD { membertype member = 1; };
struct NOEXCEPT { membertype member = 1; };
struct NONE { membertype member = 1; };
struct NOT { membertype member = 1; };
struct NOT_EQ { membertype member = 1; };
struct NULL { membertype member = 1; };
struct NULLPTR { membertype member = 1; };
struct NUM { membertype member = 1; };
struct OBJECT { membertype member = 1; };
struct OFFSET { membertype member = 1; };
struct OFFSETOF { membertype member = 1; };
struct OK { membertype member = 1; };
struct ON_OPEN { membertype member = 1; };
struct OPERATOR { membertype member = 1; };
struct OPTION { membertype member = 1; };
struct OR { membertype member = 1; };
struct OR_EQ { membertype member = 1; };
struct OVERRIDE { membertype member = 1; };
struct PACKAGE { membertype member = 1; };
struct PART { membertype member = 1; };
struct PRIV { membertype member = 1; };
struct PRIVATE { membertype member = 1; };
struct PROC { membertype member = 1; };
struct PROTECTED { membertype member = 1; };
struct PROXY { membertype member = 1; };
struct PUB { membertype member = 1; };
struct PUBLIC { membertype member = 1; };
struct PURE { membertype member = 1; };
struct RANGE { membertype member = 1; };
struct REF { membertype member = 1; };
struct REGISTER { membertype member = 1; };
struct REINTERPRET_CAST { membertype member = 1; };
struct REQUIRES { membertype member = 1; };
struct RESULT { membertype member = 1; };
struct RETHROW { membertype member = 1; };
struct RETURN { membertype member = 1; };
struct RHS { membertype member = 1; };
struct RUNE { membertype member = 1; };
struct RUNTIME_TYPE { membertype member = 1; };
struct SELECT { membertype member = 1; };
struct SELF { membertype member = 1; };
struct SEND { membertype member = 1; };
struct SET { membertype member = 1; };
struct SET_CONTROLLER { membertype member = 1; };
struct SHORT { membertype member = 1; };
struct SIGNED { membertype member = 1; };
struct SIZEOF { membertype member = 1; };
struct SOME { membertype member = 1; };
struct STATIC { membertype member = 1; };
struct STATIC_ASSERT { membertype member = 1; };
struct STATIC_CAST { membertype member = 1; };
struct STREAM { membertype member = 1; };
struct STRING { membertype member = 1; };
struct STRUCT { membertype member = 1; };
struct STUB { membertype member = 1; };
struct SUPER { membertype member = 1; };
struct SWITCH { membertype member = 1; };
struct SYNCHRONIZED { membertype member = 1; };
struct TEMPLATE { membertype member = 1; };
struct THIS { membertype member = 1; };
struct THREAD_LOCAL { membertype member = 1; };
struct THROW { membertype member = 1; };
struct TO_STRING { membertype member = 1; };
struct TRAIT { membertype member = 1; };
struct TRUE { membertype member = 1; };
struct TRY { membertype member = 1; };
struct TYPE { membertype member = 1; };
struct TYPEDEF { membertype member = 1; };
struct TYPEID { membertype member = 1; };
struct TYPENAME { membertype member = 1; };
struct TYPEOF { membertype member = 1; };
struct UINT16 { membertype member = 1; };
struct UINT32 { membertype member = 1; };
struct UINT64 { membertype member = 1; };
struct UINT8 { membertype member = 1; };
struct UNION { membertype member = 1; };
struct UNSAFE { membertype member = 1; };
struct UNSIGNED { membertype member = 1; };
struct UNSIZED { membertype member = 1; };
struct USE { membertype member = 1; };
struct USING { membertype member = 1; };
struct VALUE { membertype member = 1; };
struct VALUE_OF { membertype member = 1; };
struct VALUE_UNION { membertype member = 1; };
struct VALUES_MAP { membertype member = 1; };
struct VAR { membertype member = 1; };
struct VEC { membertype member = 1; };
struct VIRTUAL { membertype member = 1; };
struct VOID { membertype member = 1; };
struct VOLATILE { membertype member = 1; };
struct WCHAR_T { membertype member = 1; };
struct WHERE { membertype member = 1; };
struct WHICH { membertype member = 1; };
struct WHILE { membertype member = 1; };
struct WITH { membertype member = 1; };
struct XOR { membertype member = 1; };
struct XOR_EQ { membertype member = 1; };
struct XUNION { membertype member = 1; };
struct YIELD { membertype member = 1; };
struct ZX { membertype member = 1; };
struct DangerousMembers {
  ABSTRACT f0;
  ALIGNAS f1;
  ALIGNOF f2;
  AND f3;
  AND_EQ f4;
  AS f5;
  ASM f6;
  ASSERT f7;
  ASYNC f8;
  ATOMIC_CANCEL f9;
  ATOMIC_COMMIT f10;
  ATOMIC_NOEXCEPT f11;
  AUTO f12;
  AWAIT f13;
  BECOME f14;
  BITAND f15;
  BITOR f16;
  BOOL f17;
  BOX f18;
  BREAK f19;
  BYTE f20;
  CASE f21;
  CATCH f22;
  CHAN f23;
  CHAR f24;
  CHAR16_T f25;
  CHAR32_T f26;
  CLASS f27;
  CO_AWAIT f28;
  CO_RETURN f29;
  CO_YIELD f30;
  CODING_TRAITS f31;
  COMPL f32;
  CONCEPT f33;
  CONST f34;
  CONST_CAST f35;
  CONSTEXPR f36;
  CONTINUE f37;
  CONTROLLER f38;
  COVARIANT f39;
  CRATE f40;
  DECLTYPE f41;
  DECODER f42;
  DEFAULT f43;
  DEFER f44;
  DEFERRED f45;
  DELETE f46;
  DO f47;
  DOUBLE f48;
  DYNAMIC f49;
  DYNAMIC_CAST f50;
  ELSE f51;
  ENCODER f52;
  ENSURE_VALUES_INSTANTIATED f53;
  ENUM f54;
  ERR f55;
  EXPLICIT f56;
  EXPORT f57;
  EXTENDS f58;
  EXTERN f59;
  EXTERNAL f60;
  FACTORY f61;
  FALLTHROUGH f62;
  FALSE f63;
  FIDL f64;
  FIDL_TYPE f65;
  FINAL f66;
  FINALLY f67;
  FLOAT f68;
  FN f69;
  FOR f70;
  FRIEND f71;
  FUNC f72;
  FUTURE f73;
  FUTURES f74;
  GET f75;
  GO f76;
  GOTO f77;
  HAS_INVALID_TAG f78;
  HASH_CODE f79;
  IF f80;
  IMPL f81;
  IMPLEMENTS f82;
  IMPORT f83;
  IN f84;
  INDEX f85;
  INLINE f86;
  INT f87;
  INT16 f88;
  INT32 f89;
  INT64 f90;
  INT8 f91;
  INTERFACE f92;
  IS f93;
  LET f94;
  LHS f95;
  LIBRARY f96;
  LIST f97;
  LONG f98;
  LOOP f99;
  MACRO f100;
  MAP f101;
  MATCH f102;
  MIXIN f103;
  MOD f104;
  MODULE f105;
  MOVE f106;
  MUT f107;
  MUTABLE f108;
  NAMESPACE f109;
  NEVER f110;
  NEW f111;
  NO_SUCH_METHOD f112;
  NOEXCEPT f113;
  NONE f114;
  NOT f115;
  NOT_EQ f116;
  NULL f117;
  NULLPTR f118;
  NUM f119;
  OBJECT f120;
  OFFSET f121;
  OFFSETOF f122;
  OK f123;
  ON_OPEN f124;
  OPERATOR f125;
  OPTION f126;
  OR f127;
  OR_EQ f128;
  OVERRIDE f129;
  PACKAGE f130;
  PART f131;
  PRIV f132;
  PRIVATE f133;
  PROC f134;
  PROTECTED f135;
  PROXY f136;
  PUB f137;
  PUBLIC f138;
  PURE f139;
  RANGE f140;
  REF f141;
  REGISTER f142;
  REINTERPRET_CAST f143;
  REQUIRES f144;
  RESULT f145;
  RETHROW f146;
  RETURN f147;
  RHS f148;
  RUNE f149;
  RUNTIME_TYPE f150;
  SELECT f151;
  SELF f152;
  SEND f153;
  SET f154;
  SET_CONTROLLER f155;
  SHORT f156;
  SIGNED f157;
  SIZEOF f158;
  SOME f159;
  STATIC f160;
  STATIC_ASSERT f161;
  STATIC_CAST f162;
  STREAM f163;
  STRING f164;
  STRUCT f165;
  STUB f166;
  SUPER f167;
  SWITCH f168;
  SYNCHRONIZED f169;
  TEMPLATE f170;
  THIS f171;
  THREAD_LOCAL f172;
  THROW f173;
  TO_STRING f174;
  TRAIT f175;
  TRUE f176;
  TRY f177;
  TYPE f178;
  TYPEDEF f179;
  TYPEID f180;
  TYPENAME f181;
  TYPEOF f182;
  UINT16 f183;
  UINT32 f184;
  UINT64 f185;
  UINT8 f186;
  UNION f187;
  UNSAFE f188;
  UNSIGNED f189;
  UNSIZED f190;
  USE f191;
  USING f192;
  VALUE f193;
  VALUE_OF f194;
  VALUE_UNION f195;
  VALUES_MAP f196;
  VAR f197;
  VEC f198;
  VIRTUAL f199;
  VOID f200;
  VOLATILE f201;
  WCHAR_T f202;
  WHERE f203;
  WHICH f204;
  WHILE f205;
  WITH f206;
  XOR f207;
  XOR_EQ f208;
  XUNION f209;
  YIELD f210;
  ZX f211;
};
